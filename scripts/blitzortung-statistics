#!/usr/bin/python

import os, sys, math
import subprocess

import urllib

import glob, re
import optparse

import datetime, pytz

import blitzortung

whitespace = re.compile('\s+')

parser = optparse.OptionParser()

parser.add_option("--mode", dest="mode", default='histogram',
                  help="select statistics mode [histogram, data, strokes]", type="string")

parser.add_option("--time-delta", dest="timedelta", default=15, 
                  help="length of time interval in minutes", type="int")

parser.add_option("--data-path", dest="datapath", default='/var/cache/blitzortung/raw', 
                  help="path containing tracker raw files", type="string")

(options, args) = parser.parse_args()

now = datetime.datetime.utcnow()
now = now.replace(tzinfo=pytz.UTC)

delta = datetime.timedelta(minutes=options.timedelta)

files = blitzortung.files.RawFiles(options.datapath)
config = blitzortung.Config()

if options.mode == "histogram":
    timeInterval = blitzortung.data.TimeIntervals(now, delta)
    histogram = blitzortung.data.Histogram(files, timeInterval)

elif options.mode == "data":
    timeInterval = blitzortung.data.TimeRange(now, delta)
    data = blitzortung.files.Data(files, timeInterval)
    data.list()

elif options.mode == "strokes":
    timeInterval = TimeInterval(now, delta)
    participantSource = ParticipantStrokes(config)
    strokes = participantSource.get()
    totalStrokes = {}
    participatedStrokes = {}
    starttime = timeInterval.roundTime(now) + delta - datetime.timedelta(hours=2)

    userName = config.get('USERNAME')
    for stroke in strokes:

        if stroke.getTime() >= starttime:
            centertime = timeInterval.roundTime(stroke.getTime()) + delta / 2

            if totalStrokes.has_key(centertime):
                totalStrokes[centertime] += 1
            else:
                totalStrokes[centertime] = 1

            if stroke.hasParticipant(userName):
                if participatedStrokes.has_key(centertime):
                    participatedStrokes[centertime] += 1
                else:
                    participatedStrokes[centertime] = 1

    times = totalStrokes.keys()
    times.sort()

    for time in times:
        participated = '0'
        if participatedStrokes.has_key(time):
            participated = participatedStrokes[time]
        print time.strftime(Time.timeformat), totalStrokes[time], participated

elif options.mode == "residual":
    timeInterval = TimeRange(now, delta)
    serverStrokes = Strokes(config)
    strokes = serverStrokes.get(timeInterval)

    data = Data(files, timeInterval)
    rawEvents = data.get()
    cVacuum = 0.299792458 # m / ns
    cReduced = (1 - 0.0025) * cVacuum
   
    if len(rawEvents) > 0:
      rawIterator = iter(rawEvents)
      rawEvent = rawIterator.next()
	
      for stroke in strokes:
#print "stroke",stroke
	try:
	  while rawEvent.getTime() < stroke.getTime():
	    rawEvent = rawIterator.next()
#print "  event", rawEvent
#print "  distance [km]:", rawEvent.distance(stroke) / 1000.0
#print "             dt:", rawEvent.difference(stroke)
	  runtime = rawEvent.distance(stroke) / cReduced / 1000.0
	  dt = rawEvent.difference(stroke)
	  if dt.seconds == 0:
	    residualTimeUs = dt.microseconds - runtime
	    if abs(residualTimeUs) < 300:
	      timeDelta = rawEvent.difference(stroke)
	      print "%s %.1f %d %.2f %.2f" %(stroke.getTime().strftime(Time.timeformat), residualTimeUs, timeDelta.seconds*1000000 + timeDelta.microseconds, rawEvent.distance(stroke) / 1000.0, rawEvent.azimuth(stroke))
	except StopIteration:
	  break

elif options.mode == "radar":
    timeInterval = TimeRange(now, delta)
    serverStrokes = Strokes(config)
    strokes = serverStrokes.get()

    data = Data(files, timeInterval)
    rawEvents = data.get()
   
    if len(rawEvents) > 0:
      rawIterator = iter(rawEvents)
      rawEvent = rawIterator.next()
	
      for stroke in strokes:
	print rawEvent.azimuth(stroke), rawEvent.distance(stroke)/1000.0
else:
    raise Exception("unknown mode '%s'" %(options.mode))
