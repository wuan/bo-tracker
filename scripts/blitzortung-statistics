#!/usr/bin/python

import os, sys, math
import subprocess

import urllib

import glob, re
import optparse

import datetime, pytz

whitespace = re.compile('\s+')
timeformat = '%Y-%m-%d %H:%M:%S'

class Config():
    def __init__(self, configfilename=None):

        self.config = {}

        if configfilename == None:
            configfilename = '/etc/default/blitzortung-tracker'

        configfile = open(configfilename, 'r')
        for line in configfile:
            line = line.strip()

            if len(line) > 0 and line[0] != '#':

                index = line.find('=')

                variable = line[0:index]

                basename = 'BLITZORTUNG_'

                if variable.find(' ') < 0:
                    if variable[:len(basename)] == basename:
                        self.config[variable[len(basename):].upper()] = line[index+1:].replace('"', '')

    def get(self, key):
        key = key.upper()

        if self.config.has_key(key):
            return self.config[key]

        raise Exception("Config.get() key not found")

class Point():

    __whitespaceRe = re.compile('\s+')

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __invgeod(self, other):
        pipe = subprocess.Popen(['invgeod', '+ellps=WGS84', '+units=m'], stdin = subprocess.PIPE, stdout = subprocess.PIPE)
        (output, error) = pipe.communicate("%f %f %f %f" %(self.y, self.x, other.y, other.x))
        return Point.__whitespaceRe.split(output.strip())

    def distance(self, other):
        return float(self.__invgeod(other)[2])

    def azimuth(self, other):
        return float(self.__invgeod(other)[0])

class Time():

    def __init__(self, time):
        self.time = time

    def difference(self, other):
        return self.time - other.time

class Event(Point, Time):

    def __init__(self, x, y, time):
        Point.__init__(self, x, y)
        Time.__init__(self, time)

class Stroke(Event):
    '''
    classdocs
    '''

    def __init__(self, data = None):
        if data != None:
            ' Construct stroke from blitzortung text format data line '
            fields = data.split(' ')
            if len(fields) >= 8:
                nanoseconds = int(fields[1][-9:])
                time = datetime.datetime.strptime(fields[0] + ' ' + fields[1][:-10], timeformat)
                time = time.replace(microsecond=int(round(nanoseconds / 1000.0)), tzinfo=pytz.UTC)
                position_x = float(fields[3])
                position_y = float(fields[2])
                Event.__init__(self, position_x, position_y, time)

                self.amplitude = float(fields[4][:-2])
                self.typeVal = int(fields[5])
                self.error2d = int(fields[6][:-1])
                if self.error2d < 0:
                    self.error2d = 0
                self.stationcount = int(fields[7])
                self.participants = []
                if (len(fields) >=9):
                    for index in range(8,len(fields)):
                        self.participants.append(fields[index])
            else:
                raise Error("not enough data fields from stroke data line '%s'" %(data))
        self.height = 0.0

    def getTime(self):
        return self.time

    def setTime(self, time):
        self.time = time

    def getPosition(self):
        return self.position

    def setPosition(self, position):
        self.position = position

    def getHeight(self):
        return self.height

    def setHeight(self, height):
        self.height = height

    def getAmplitude(self):
        return self.amplitude

    def setAmplitude(self, amplitude):
        self.amplitude = amplitude

    def getType(self):
        return self.typeVal

    def setType(self, typeVal):
        self.typeVal = typeVal

    def getError2D(self):
        return self.error2d

    def setError2D(self, error2d):
        self.error2d = error2d

    def getStationCount(self):
        return self.stationcount

    def setStationCount(self, stationcount):
        self.stationcount = stationcount

    def hasParticipant(self, participant):
        return self.participants.count(participant) > 0
    
    def __str__(self):
        return str(self.time) + ' ' + str(self.x) + ' ' + str(self.y) + ' ' + str(self.height) + ' ' + str(self.amplitude) + ' ' + str(self.typeVal) + ' ' + str(self.error2d) + ' ' + str(self.stationcount)

class RawFiles:

    def __init__(self, rawPath):
        rawFileNames = glob.glob(os.path.join(rawPath, '*.bor'))

        rawFileNames.sort()

        self.rawFiles = {}

        for rawFileName in rawFileNames:
            date = datetime.datetime.strptime(rawFileName[-12:-4], '%Y%m%d').date()
            if not self.rawFiles.has_key(date):
                self.rawFiles[date] = rawFileName
            else:
                raise Exception("ERROR: double date! " + rawFileName + " vs. " + self.rawFiles[date])

    def get(self, date):
        if self.rawFiles.has_key(date):
            return self.rawFiles[date]
        else:
            raise Exception("no file for date "+date.strftime('%Y-%m-%d'))

class TimeInterval():

    def __init__(self, endTime, deltaTime=datetime.timedelta(hours=1)):
        self.deltaTime = deltaTime
        self.endTime = self.roundTime(endTime)

        self.time = self.endTime - self.deltaTime

    def totalSeconds(self, time):
        ' return the total seconds of the given time or datetime (relative to midnight) '

        if isinstance(time, datetime.datetime):
            return time.hour * 3600 + time.minute * 60 + time.second
        elif isinstance(time, datetime.timedelta):
            return time.seconds + time.days * 24 * 3600
        else:
            raise Exception("unhandled type"+type(time))

    def roundTime(self, time):
        deltaSeconds = self.totalSeconds(self.deltaTime)

        seconds =  self.totalSeconds(time)
        seconds /= deltaSeconds
        seconds *= deltaSeconds

        if isinstance(time, datetime.datetime):
            return time.replace(hour = seconds/3600, minute= seconds / 60 % 60, second= seconds % 60, microsecond=0)
        else:
            return datetime.timedelta(seconds=seconds)

    def hasNext(self):
        return False

    def next(self):
        raise Exception(' no next interval ')

    def getStartTime(self):
        return self.time

    def getEndTime(self):
        return self.time + self.deltaTime

    def getCenterTime(self):
        return self.time + self.deltaTime / 2

    def getEndMinute(self):
        return self.getEndTime() - datetime.timedelta(minutes=1)


class TimeIntervals(TimeInterval):

    def __init__(self, endTime, deltaTime=datetime.timedelta(minutes=15), totalDuration=datetime.timedelta(days=1)):
        TimeInterval.__init__(self, endTime, deltaTime)

        self.totalDuration = self.roundTime(totalDuration)

        print "TimeInvervals ",self.deltaTime, self.endTime, self.totalDuration

        self.time = self.endTime - self.totalDuration

    def hasNext(self):
        return self.time + self.deltaTime < self.endTime

    def next(self):
        if self.hasNext():
            self.time += self.deltaTime
            return self.time
        else:
            raise Exception('no more time intervals')

class Data:

    def __init__(self, files, time):
        self.files = files
        self.time = time

    def get(self):
        start = self.time.getStartTime()
        starttime = start.strftime("%H%M")
        startdate = start.strftime("%Y%m%d")

        end = self.time.getEndMinute()
        endtime = end.strftime("%H%M")

        try:
            rawFile = files.get(start.date())

            data = subprocess.Popen(['blitzortung-data','-i', rawFile, '-s', starttime, '-e', endtime], stdout=subprocess.PIPE)

            (output, error) = data.communicate()
        except:
            pass
            output = ""
            print "ignore errors"

        return output.splitlines()

    def list(self):
        for line in self.get():
            print line.strip()

class Histogram(Data):

    def __init__(self, files, time):
        Data.__init__(self, files, time)

        while True:

            # count the number of samples
            counter = 0
            ampsum = 0.0
            for line in self.get():
                fields = whitespace.split(line)

                xamp = float(fields[7])
                yamp = float(fields[8])
                ampsum += math.sqrt(xamp * xamp + yamp * yamp)
                counter += 1

            time = self.time.getCenterTime()

            if counter > 0:
                avgamp = ampsum/counter
            else:
                avgamp = '?'
            print time, counter, avgamp

            if not self.time.hasNext():
                break

            self.time.next()

class StrokesUrl:

    def __init__(self, baseurl):
        self.url = baseurl

    def add(self, name, value):
        self.url += '&' + str(name).strip() + '=' + str(value).strip()

    def get(self):
        return self.url

    def readData(self):
        urlconnection = urllib.urlopen(self.url)
        data = urlconnection.read().strip()
        urlconnection.close()
        return data

    def get(self):
        strokes = []
        for line in self.readData().split('\n'):
            strokes.append(Stroke(line))
        return strokes

class Strokes(StrokesUrl):

    def __init__(self, config):
        StrokesUrl.__init__(self, 'http://'+config.get('username')+':'+config.get('password')+'@blitzortung.tmt.de/Data/Protected/strikes.txt')

class ParticipantStrokes(StrokesUrl):

    def __init__(self, config):
        StrokesUrl.__init__(self, 'http://'+config.get('username')+':'+config.get('password')+'@blitzortung.tmt.de/Data/Protected/participants.txt')

parser = optparse.OptionParser()

parser.add_option("--mode", dest="mode", default='histogram',
                  help="select statistics mode [histogram, data, strokes]", type="string")

parser.add_option("--time-delta", dest="timedelta", default=15, 
                  help="length of time interval in minutes", type="int")

parser.add_option("--data-path", dest="datapath", default='/var/cache/blitzortung/raw', 
                  help="path containing tracker raw files", type="string")

(options, args) = parser.parse_args()


now = datetime.datetime.utcnow()
now = now.replace(tzinfo=pytz.UTC)

delta = datetime.timedelta(minutes=options.timedelta)

files = RawFiles(options.datapath)


if options.mode == "histogram":
    timeInterval = TimeIntervals(now, delta)
    histogram = Histogram(files, timeInterval)

elif options.mode == "data":
    timeInterval = TimeInterval(now, delta)
    data = Data(files, timeInterval)
    data.list()

elif options.mode == "strokes":
    timeInterval = TimeInterval(now, delta)
    config = Config()
    participantSource = ParticipantStrokes(config)
    strokes = participantSource.get()
    totalStrokes = {}
    participatedStrokes = {}
    starttime = timeInterval.roundTime(now) + delta - datetime.timedelta(hours=2)

    userName = config.get('USERNAME')
    for stroke in strokes:

        if stroke.getTime() >= starttime:
            centertime = timeInterval.roundTime(stroke.getTime()) + delta / 2

            if totalStrokes.has_key(centertime):
                totalStrokes[centertime] += 1
            else:
                totalStrokes[centertime] = 1

            if stroke.hasParticipant(userName):
                if participatedStrokes.has_key(centertime):
                    participatedStrokes[centertime] += 1
                else:
                    participatedStrokes[centertime] = 1

    times = totalStrokes.keys()
    times.sort()

    for time in times:
        participated = '0'
        if participatedStrokes.has_key(time):
            participated = participatedStrokes[time]
        print time.strftime(timeformat), totalStrokes[time], participated

elif options.mode == "test":
    point1 = Point(11,49)
    point2 = Point(11,50)
    print point1.distance(point2)

else:
    raise Exception("unknown mode '%s'" %(options.mode))
